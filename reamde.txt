SELECT f_name_lc,
       sha256,
       COUNT(1),
       ARRAY_TO_STRING(ARRAY_AGG(DISTINCT CONCAT (device_uid)),', '),
       ARRAY_TO_STRING(ARRAY_AGG(DISTINCT CONCAT (f_parent)),', ')
FROM sm_file_card
WHERE sha256 IS NOT NULL
GROUP BY sha256,
         f_name_lc
ORDER BY 3 DESC

-------------------------------------------------------------------------------------------------------------------------------------

SELECT * FROM   pg_settings WHERE  name in (
'max_connections',
'shared_buffers',
'effective_cache_size',
'maintenance_work_mem',
'checkpoint_completion_target',
'wal_buffers',
'default_statistics_target',
'random_page_cost',
'effective_io_concurrency',
'work_mem',
'min_wal_size',
'max_wal_size'
);




ALTER SYSTEM SET
 max_connections = '100';
ALTER SYSTEM SET
 shared_buffers = '256MB';
ALTER SYSTEM SET
 effective_cache_size = '768MB';
ALTER SYSTEM SET
 maintenance_work_mem = '64MB';
ALTER SYSTEM SET
 checkpoint_completion_target = '0.9';
ALTER SYSTEM SET
 wal_buffers = '7864kB';
ALTER SYSTEM SET
 default_statistics_target = '100';
ALTER SYSTEM SET
 random_page_cost = '1.1';
ALTER SYSTEM SET
 effective_io_concurrency = '200';
ALTER SYSTEM SET
 work_mem = '1310kB';
ALTER SYSTEM SET
 min_wal_size = '1GB';
ALTER SYSTEM SET
 max_wal_size = '2GB';


-------------------------------------------------------------------------------------------------------------------------------------

SELECT COALESCE(bgl.relation::regclass::TEXT,bgl.locktype) AS locked_item,
       NOW() - bda.query_start AS waiting_duration,
       bda.pid AS blocked_pid,
       bda.query AS blocked_query,
       bdl.mode AS blocked_mode,
       bga.pid AS blocking_pid,
       bga.query AS blocking_query,
       bgl.mode AS blocking_mode
FROM pg_catalog.pg_locks bdl
  JOIN pg_stat_activity bda ON bda.pid = bdl.pid
  JOIN pg_catalog.pg_locks bgl
    ON bgl.pid != bdl.pid
   AND (bgl.transactionid = bdl.transactionid
    OR bgl.relation = bdl.relation
   AND bgl.locktype = bdl.locktype)
  JOIN pg_stat_activity bga
    ON bga.pid = bgl.pid
   AND bga.datid = bda.datid
WHERE NOT bdl.granted
AND   bga.datname = current_database();

-------------------------------------------------------------------------------------------------------------------------------------

SELECT to_tsvector('My name is Alex and I''m a software developer.');

SELECT to_tsvector('russian','Меня зовут Саша и я программист.');

SELECT plainto_tsquery('Hello world');

-------------------------------------------------------------------------------------------------------------------------------------

[PSQLException: ERROR: column x2.label does not exist Hint: Perhaps you meant to reference the column "x2.label_v". Position: 43]

play.api.http.HttpErrorHandlerExceptions$$anon$1: Execution exception[[PSQLException: ERROR: column x2.label does not exist
  Hint: Perhaps you meant to reference the column "x2.label_v".
  Position: 43]]
	at play.api.http.HttpErrorHandlerExceptions$.throwableToUsefulException(HttpErrorHandler.scala:351)
	at play.api.http.DefaultHttpErrorHandler.onServerError(HttpErrorHandler.scala:267)
	at play.core.server.AkkaHttpServer$$anonfun$1.applyOrElse(AkkaHttpServer.scala:448)
	at play.core.server.AkkaHttpServer$$anonfun$1.applyOrElse(AkkaHttpServer.scala:446)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:453)
	at akka.dispatch.BatchingExecutor$AbstractBatch.processBatch(BatchingExecutor.scala:55)
	at akka.dispatch.BatchingExecutor$BlockableBatch.$anonfun$run$1(BatchingExecutor.scala:92)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.BlockContext$.withBlockContext(BlockContext.scala:94)
	at akka.dispatch.BatchingExecutor$BlockableBatch.run(BatchingExecutor.scala:92)
Caused by: org.postgresql.util.PSQLException: ERROR: column x2.label does not exist
  Hint: Perhaps you meant to reference the column "x2.label_v".
  Position: 43
	at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2440)
	at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:2183)
	at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:308)
	at org.postgresql.jdbc.PgStatement.executeInternal(PgStatement.java:441)
	at org.postgresql.jdbc.PgStatement.execute(PgStatement.java:365)
	at org.postgresql.jdbc.PgPreparedStatement.executeWithFlags(PgPreparedStatement.java:143)
	at org.postgresql.jdbc.PgPreparedStatement.execute(PgPreparedStatement.java:132)
	at com.zaxxer.hikari.pool.ProxyPreparedStatement.execute(ProxyPreparedStatement.java:44)
	at com.zaxxer.hikari.pool.HikariProxyPreparedStatement.execute(HikariProxyPreparedStatement.java)
	at slick.jdbc.StatementInvoker.results(StatementInvoker.scala:39)

-------------------------------------------------------------------------------------------------------------------------------------

select F_PARENT,
       sm_file_card.F_NAME,
       to_char(sm_file_card.F_LAST_MODIFIED_DATE, 'YYYY-MM-DD HH24:MI:SS') F_LAST_MODIFIED_DATE,
       to_char(sm_exif.DATE_TIME, 'YYYY-MM-DD HH24:MI:SS')                 DATE_TIME,
       sm_exif.MAKE,
       sm_exif.MODEL
from sm_file_card
         inner join sm_exif on sm_exif.ID = sm_file_card.ID
where sm_exif.ID is not null
  and sm_exif.DATE_TIME is not null
  and date_part('day', sm_exif.DATE_TIME) != date_part('day', sm_file_card.F_LAST_MODIFIED_DATE)
order by DATE_TIME desc
;



-------------------------------------------------------------------------------------------------------------------------------------

CREATE EXTENSION pg_trgm with schema public;

CREATE INDEX sm_file_card_f_name_lc_gin_trgm_idx ON sm_file_card USING gin(LOWER(f_name_lc) gin_trgm_ops);


explain analyse
SELECT x2.x3,
       x2.x4,
       x2.x5,
       x2.x6,
       x2.x7,
       x2.x8
FROM (SELECT x9."f_name_lc" AS x3,
             x9."f_name" AS x4,
             x9."f_parent" AS x5,
             x9."sha256" AS x6,
             (CASE WHEN (x10."id" IS NOT NULL) THEN x10."label_v" ELSE NULL END) AS x7,
             COUNT(1) AS x8
      FROM "sm_file_card" x9
        LEFT OUTER JOIN "sm_device" x10 ON x9."device_uid" = x10."uid"
      WHERE x9."f_name_lc" LIKE '%%'
      GROUP BY x9."f_name_lc",
               x9."f_name",
               x9."f_parent",
               x9."sha256",
               (CASE WHEN (x10."id" IS NOT NULL) THEN x10."label_v" ELSE NULL END) LIMIT 10 OFFSET 0) x2
ORDER BY x2.x4

-------------------------------------------------------------------------------------------------------------------------------------

JdbcCapabilities.insertOrUpdate;
[debug] s.j.J.statementAndParameter - Executing prepared update: HikariProxyPreparedStatement@1198385275 wrapping update "sm_exif" set "date_time"=?,"date_time_original"=?,"date_time_digitized"=?,"make"=?,"model"=?,"software"=?,"exif_image_width"=?,"exif_image_height"=?,"gps_version_id"=?,"gps_latitude_ref"=?,"gps_latitude"=?,"gps_longitude_ref"=?,"gps_longitude"=?,"gps_altitude_ref"=?,"gps_altitude"=?,"gps_time_stamp"=?,"gps_processing_method"=?,"gps_date_stamp"=?,"gps_latitude_dec"=?,"gps_longitude_dec"=? where "id"=?; insert into "sm_exif" ("id","date_time","date_time_original","date_time_digitized","make","model","software","exif_image_width","exif_image_height","gps_version_id","gps_latitude_ref","gps_latitude","gps_longitude_ref","gps_longitude","gps_altitude_ref","gps_altitude","gps_time_stamp","gps_processing_method","gps_date_stamp","gps_latitude_dec","gps_longitude_dec") select ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,? where not exists (select 1 from "sm_exif" where "id"=?)
[debug] s.j.J.statementAndParameter - Executing prepared update: HikariProxyPreparedStatement@408292370 wrapping insert into "sm_exif" ("id","date_time","date_time_original","date_time_digitized","make","model","software","exif_image_width","exif_image_height","gps_version_id","gps_latitude_ref","gps_latitude","gps_longitude_ref","gps_longitude","gps_altitude_ref","gps_altitude","gps_time_stamp","gps_processing_method","gps_date_stamp","gps_latitude_dec","gps_longitude_dec") values ('3FFE4FE6CBEFED63B282D7763F472C44A24A9DF400B1ACAD6EF22D674602CAAD',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL) on conflict ("id") do update set "date_time"=EXCLUDED."date_time","date_time_original"=EXCLUDED."date_time_original","date_time_digitized"=EXCLUDED."date_time_digitized","make"=EXCLUDED."make","model"=EXCLUDED."model","software"=EXCLUDED."software","exif_image_width"=EXCLUDED."exif_image_width","exif_image_height"=EXCLUDED."exif_image_height","gps_version_id"=EXCLUDED."gps_version_id","gps_latitude_ref"=EXCLUDED."gps_latitude_ref","gps_latitude"=EXCLUDED."gps_latitude","gps_longitude_ref"=EXCLUDED."gps_longitude_ref","gps_longitude"=EXCLUDED."gps_longitude","gps_altitude_ref"=EXCLUDED."gps_altitude_ref","gps_altitude"=EXCLUDED."gps_altitude","gps_time_stamp"=EXCLUDED."gps_time_stamp","gps_processing_method"=EXCLUDED."gps_processing_method","gps_date_stamp"=EXCLUDED."gps_date_stamp","gps_latitude_dec"=EXCLUDED."gps_latitude_dec","gps_longitude_dec"=EXCLUDED."gps_longitude_dec"



-------------------------------------------------------------------------------------------------------------------------------------
              /*
                            logger.info(s"getNano = ${row._5.getNano}")
                            logger.info(s"getNano = ${row._5.toString}")
                            logger.info(s"toInstant = ${row._5.toInstant(ZoneOffset.UTC)}")
                            logger.info(s"toEpochMilli = ${row._5.toInstant(ZoneOffset.UTC).toEpochMilli}")
                            logger.info(s"FileTime getNano = ${FileTime.fromMillis(row._5.getNano)}")
                            logger.info(s"FileTime from = ${FileTime.from(row._5.getNano, TimeUnit.NANOSECONDS)}")
                            logger.info(s"FileTime fromMillis = ${FileTime.fromMillis(row._5.toInstant(ZoneOffset.UTC).toEpochMilli)}")
              */

              logger.info("!!!!!")
              logger.info(s"getNano = ${row._5.toString}")
              logger.info(s"MILLI_OF_SECOND = ${row._5.getLong(ChronoField.MILLI_OF_SECOND)}")
              logger.info(s"MILLI_OF_DAYMILLI_OF_DAY = ${row._5.getLong(ChronoField.MILLI_OF_DAY)}")
              //              logger.info(s"MILLI_OF_DAYMILLI_OF_DAY = ${row._5.toInstant(ZoneOffset.UTC).toEpochMilli)}")
              import java.time.ZoneId
              import java.time.ZonedDateTime
              val zdtSys = ZonedDateTime.of(row._5, ZoneId.systemDefault())
              val zdtUtc = ZonedDateTime.of(row._5, ZoneOffset.UTC)
              logger.info(s"zdtSys = $zdtSys")
              logger.info(s"zdtUtc = $zdtUtc")
              //              logger.info(s"zdt = ${ZoneId.getAvailableZoneIds}")
              //              logger.info(s"zdt = ${ZoneId.SHORT_IDS}")
